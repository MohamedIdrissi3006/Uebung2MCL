#include "mcl_localization/mcl.hpp"
#include <rclcpp/rclcpp.hpp>
#include <nav_msgs/msg/odometry.hpp>
#include <sensor_msgs/msg/point_cloud2.hpp>
#include <geometry_msgs/msg/pose_stamped.hpp>
#include <geometry_msgs/msg/pose_array.hpp>
#include <sensor_msgs/point_cloud2_iterator.hpp>

class MCLNode : public rclcpp::Node
{
public:
  MCLNode()
  : Node("mcl_node"), mcl_(200)
  {
    mcl_.initializeUniform(-10.0, 10.0, -10.0, 10.0);
    
    odom_sub_ = create_subscription<nav_msgs::msg::Odometry>(
      "/robot_noisy", 10,
      std::bind(&MCLNode::odomCallback, this, std::placeholders::_1));
      
    landmarks_sub_ = create_subscription<sensor_msgs::msg::PointCloud2>(
      "/landmarks_observed", 10,
      std::bind(&MCLNode::landmarksCallback, this, std::placeholders::_1));
      
    pose_pub_ = create_publisher<geometry_msgs::msg::PoseStamped>(
      "/mcl_pose", 10);
      
    // Publisher for top 10 particles
    particles_pub_ = create_publisher<geometry_msgs::msg::PoseArray>(
      "/mcl_particles_top10", 10);
  }

private:
  MCL mcl_;
  rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr odom_sub_;
  rclcpp::Subscription<sensor_msgs::msg::PointCloud2>::SharedPtr landmarks_sub_;
  rclcpp::Publisher<geometry_msgs::msg::PoseStamped>::SharedPtr pose_pub_;
  rclcpp::Publisher<geometry_msgs::msg::PoseArray>::SharedPtr particles_pub_;
  
  double last_x_ = 0.0;
  double last_y_ = 0.0;
  double last_theta_ = 0.0;
  bool first_odom_ = true;

  void odomCallback(const nav_msgs::msg::Odometry::SharedPtr msg)
  {
    double x = msg->pose.pose.position.x;
    double y = msg->pose.pose.position.y;
    
    // FIXED: Proper quaternion to yaw conversion
    auto q = msg->pose.pose.orientation;
    double siny = 2.0 * (q.w * q.z + q.x * q.y);
    double cosy = 1.0 - 2.0 * (q.y * q.y + q.z * q.z);
    double theta = std::atan2(siny, cosy);

    if (!first_odom_)
    {
      double dx = x - last_x_;
      double dy = y - last_y_;
      double dtheta = theta - last_theta_;
      
      // Normalize angle difference
      while (dtheta > M_PI) dtheta -= 2.0 * M_PI;
      while (dtheta < -M_PI) dtheta += 2.0 * M_PI;
      
      mcl_.motionUpdate(dx, dy, dtheta);
    }
    
    first_odom_ = false;
    last_x_ = x;
    last_y_ = y;
    last_theta_ = theta;
  }

  void landmarksCallback(const sensor_msgs::msg::PointCloud2::SharedPtr msg)
  {
    std::vector<double> obs_x, obs_y;
    std::vector<double> lm_x, lm_y;
    
    // FIXED: Parse PointCloud2 to extract observations
    sensor_msgs::PointCloud2ConstIterator<float> iter_x(*msg, "x");
    sensor_msgs::PointCloud2ConstIterator<float> iter_y(*msg, "y");
    
    for (; iter_x != iter_x.end(); ++iter_x, ++iter_y)
    {
      obs_x.push_back(*iter_x);
      obs_y.push_back(*iter_y);
    }
    
    // Known landmark positions (example - adjust to your map)
    // You need to provide the actual landmark positions in the global frame
    lm_x = {1.0, 5.0, -3.0, 8.0};  // Replace with actual positions
    lm_y = {2.0, -4.0, 6.0, -2.0}; // Replace with actual positions
    
    // Only update if we have observations
    if (!obs_x.empty() && obs_x.size() == lm_x.size())
    {
      mcl_.measurementUpdate(obs_x, obs_y, lm_x, lm_y, 0.2);
      mcl_.resample();
    }
    
    // Publish estimated pose
    auto est = mcl_.estimatePose();
    geometry_msgs::msg::PoseStamped pose;
    pose.header.stamp = now();
    pose.header.frame_id = "map";
    pose.pose.position.x = est.x;
    pose.pose.position.y = est.y;
    pose.pose.orientation.z = std::sin(est.theta / 2.0);
    pose.pose.orientation.w = std::cos(est.theta / 2.0);
    pose_pub_->publish(pose);
    
    // FIXED: Publish top 10 particles
    publishTopParticles();
  }
  
  void publishTopParticles()
  {
    auto particles = mcl_.particles();
    
    // Sort particles by weight (descending)
    std::vector<MCL::Particle> sorted_particles = particles;
    std::sort(sorted_particles.begin(), sorted_particles.end(),
              [](const MCL::Particle& a, const MCL::Particle& b) {
                return a.weight > b.weight;
              });
    
    // Create PoseArray with top 10
    geometry_msgs::msg::PoseArray pose_array;
    pose_array.header.stamp = now();
    pose_array.header.frame_id = "map";
    
    int count = std::min(10, static_cast<int>(sorted_particles.size()));
    for (int i = 0; i < count; ++i)
    {
      geometry_msgs::msg::Pose pose;
      pose.position.x = sorted_particles[i].x;
      pose.position.y = sorted_particles[i].y;
      pose.orientation.z = std::sin(sorted_particles[i].theta / 2.0);
      pose.orientation.w = std::cos(sorted_particles[i].theta / 2.0);
      pose_array.poses.push_back(pose);
    }
    
    particles_pub_->publish(pose_array);
  }
};

int main(int argc, char **argv)
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<MCLNode>());
  rclcpp::shutdown();
  return 0;
}
